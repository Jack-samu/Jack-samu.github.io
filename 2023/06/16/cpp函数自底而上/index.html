<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->
<!-- keywords -->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="Jack">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Jack">
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    <meta name="description" content="小杰的技术博客">
    <meta name="description" content="最近一直在复习cpp的基础概念，但对于cpp中的函数还是有点莫名，直到cpp编译器会把类转换成c中的struct结构体，那么函数呢？对于函数，编译器又做了什么处理？所以针对函数，这里进行一下研究。">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp函数自底而上">
<meta property="og:url" content="https://jack-samu.github.io/2023/06/16/cpp%E5%87%BD%E6%95%B0%E8%87%AA%E5%BA%95%E8%80%8C%E4%B8%8A/index.html">
<meta property="og:site_name" content="Jack &#39;s Studio">
<meta property="og:description" content="最近一直在复习cpp的基础概念，但对于cpp中的函数还是有点莫名，直到cpp编译器会把类转换成c中的struct结构体，那么函数呢？对于函数，编译器又做了什么处理？所以针对函数，这里进行一下研究。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-06-16T14:51:50.000Z">
<meta property="article:modified_time" content="2025-03-12T08:38:51.012Z">
<meta property="article:author" content="Jack">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="函数">
<meta property="article:tag" content="gdb">
<meta name="twitter:card" content="summary">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/avatar/takashi.jpg">
    <title>cpp函数自底而上 · Jack&#39;s Studio</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .footer-fixed-btn,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(
            -45deg,
            #444 0,
            #444 80px,
            #333 80px,
            #333 160px
        );
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link id="stylesheet-fancybox" rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link id="stylesheet-base" rel="preload" href="/css/style.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link id="stylesheet-mobile" rel="preload" href="/css/mobile.css" as="style" onload="this.onload=null;this.rel='stylesheet';this.media='screen and (max-width: 960px)'">
    <link id="stylesheet-theme-dark" rel="preload" href="/css/dark.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    <!-- 百度统计  -->
    <!-- 谷歌统计  -->
    <!-- Google tag (gtag.js) -->
<meta name="generator" content="Hexo 7.3.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
        <body class="post-body">
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        <div class="header-sidebar-menu">
            <div style="padding-left: 1px;">&#xe775;</div>
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href="/">Jack's Studio.</a>
        </span>
    </div>
    <!-- toggle banner -->
    <div class="banner">
        <div class="blog-title header-element">
            <a href="/">Jack&#39;s Studio.</a>
        </div>
        <div class="post-title header-element">
            <a href="#" class="post-name">cpp函数自底而上</a>
        </div>
    </div>
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- donate button -->

    <!-- back to top button -->
    <div class="footer-fixed-btn footer-fixed-btn--hidden back-top">
        <div>&#xe639;</div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="    height:50vh;
">
    <!-- 主页  -->
    <!-- 404页  -->
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/detail-head.png)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
                cpp函数自底而上
            <!-- 404 -->
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            <!-- 404 -->
        </p>
        <!-- 文章页 meta -->
            <div class="post-intros">
                <!-- 文章页标签  -->
                    <div class="post-intro-tags" >
        <a class="post-tag" href="javascript:void(0);" data-tags="cpp">cpp</a>
        <a class="post-tag" href="javascript:void(0);" data-tags="函数">函数</a>
        <a class="post-tag" href="javascript:void(0);" data-tags="gdb">gdb</a>
</div>

                <!-- 文章字数统计 -->
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">5.3k</span>阅读时长: <span class="post-count reading-time">22 min</span></span>
                    </div>
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2023/06/16</span>
                    <!-- busuanzi -->
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" alt="loading">
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <p><font face="楷体"></p>
<p>最近一直在复习cpp的基础概念，但对于cpp中的函数还是有点莫名，直到cpp编译器会把类转换成c中的struct结构体，那么函数呢？对于函数，编译器又做了什么处理？所以针对函数，这里进行一下研究。</p>
<span id="more"></span>
<h2 id="一基本">一、基本</h2>
<p>一个可执行文件，它一般由代码区和数据区组成，在加载到内存中进程地址空间中，它就由代码区、数据区、堆区、栈区和堆区栈区之间的动态变化区域组成。函数会发挥什么作用呢？针对一个函数被调用的过程，就是栈帧的创建到销毁的过程。那么一个栈帧的结构是怎么样的呢？首先，关注下面几个问题：</p>
<blockquote>
<p>函数栈帧是什么？ 函数调用过程 函数调用中，参数如何传递？传参顺序？
形参是如何通过实参进行实例化？ 函数如何返回？
局部变量的存在是怎么样的？</p>
</blockquote>
<p>首先，函数调用时可以循环嵌套的，程序经常在执行的时候，出现对另一个函数的调用，然后在外部函数调用完毕后，再返回原地址继续执行，比如main中调用printf或者cout来输出语句。这种先进后出的方式，栈就很合适应对处理，所以针对函数的调用，往往和栈区挂钩。另外，函数的执行轨迹，就是一个二叉树的遍历过程，所以数的遍历往往和递归或者栈进行挂钩。</p>
<p>在栈区中，有着栈帧的这么一块内存，专门存储函数的局部变量、传入参数和返回地址等信息，针对函数的调用，栈区中都会创建一个新的栈帧，其大小取决于函数局部变量和参数数据量。</p>
<blockquote>
<ul>
<li>调用者把参数和返回地址压入栈中；</li>
<li>然后转换控制权给被调用函数的入口地址，再创建新的栈帧；</li>
<li>被调用函数在新的栈帧中进行局部变量的初始化和使用，还有指令的执行；</li>
<li>函数执行完毕，就将返回值存储在约定地址，恢复调用者调用地址；</li>
<li>切换控制权给调用者，销毁当前函数栈帧，释放空间；</li>
<li>调用者获取函数返回值，继续执行后续操作</li>
</ul>
</blockquote>
<p>如上就是一个函数调用的过程中，栈区和栈帧的变化。</p>
<h3 id="进门看看">1.1 进门看看</h3>
<p>了解函数，绕不开栈区和栈帧，要了解底层架构，接触汇编是比较直接的途径了。如下是一个简单的测试用cpp代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, world.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后进行汇编，生成汇编文件查看一下信息，一般可以通过<code>gcc -S</code>的做法生成中间的汇编文件，下面就是<code>g++ -S test.cpp -o test.s</code>得到的test.s文件，查看main和show信息，摘取两部分的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">_Z4showv:</span><br><span class="line">.LFB1573:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.seh_pushreg	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.seh_setframe	%rbp, 0</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	.seh_stackalloc	32</span><br><span class="line">	.seh_endprologue</span><br><span class="line">	leaq	.LC0(%rip), %rdx</span><br><span class="line">	movq	.refptr._ZSt4cout(%rip), %rcx</span><br><span class="line">	call	_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc</span><br><span class="line">	movq	.refptr._ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(%rip), %rdx</span><br><span class="line">	movq	%rax, %rcx</span><br><span class="line">	call	_ZNSolsEPFRSoS_E</span><br><span class="line">	nop</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br><span class="line">main:</span><br><span class="line">.LFB1574:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.seh_pushreg	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.seh_setframe	%rbp, 0</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	.seh_stackalloc	32</span><br><span class="line">	.seh_endprologue</span><br><span class="line">	call	__main</span><br><span class="line">	call	_Z4showv</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>嗯，还是不太美观，g++编译时，添加一下参数<code>-fno-asynchronous-unwind-tables</code>，这样得到的汇编码就比较没换了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">_Z4showv:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	leaq	.LC0(%rip), %rdx</span><br><span class="line">	movq	.refptr._ZSt4cout(%rip), %rcx</span><br><span class="line">	call	_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc</span><br><span class="line">	movq	.refptr._ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(%rip), %rdx</span><br><span class="line">	movq	%rax, %rcx</span><br><span class="line">	call	_ZNSolsEPFRSoS_E</span><br><span class="line">	nop</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br><span class="line">main:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	call	__main</span><br><span class="line">	call	_Z4showv</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>从上面就可以看得出，两个函数的汇编码都有着比较一致的结构，作为开始的pushq、movq和subq三剑客开头，leave和ret结尾，并且中间才是正经处理。首先关注开头部分rbp和rsp两个寄存器。要知道的是，在很多的解释中，这两个寄存器应该是EBP和ESP才对，这里的rbp和rsp是对应的当前x86_64架构，前面的是针对简单x86，所以才有不同。那么它们发挥什么作用呢？</p>
<blockquote>
<p>rbp和rsp，前者是函数调用前保存函数栈帧基址的寄存器，函数被调用后，创建一个新的栈帧，rbp寄存器就存储这个栈帧的基址，通过rbp寄存器就可以很方便的访问栈帧中数据；
后者是指示栈区顶部地址的寄存器，要知道的是，栈区是位于进程地址空间中最高地址的部分，主要从上而下进行扩展，所以它的顶部，也就是栈区中实际地址最小的地方，当函数调用开始，它会继续向下移动，为新的栈帧分配内存；
另外的rip，这个寄存器保存的是指令地址，在函数调用后，会指向被调用函数的入口地址，开始函数指令的调用，函数调用结束以后，rip就恢复到调用者调用函数指令的下一条指令。</p>
</blockquote>
<p>简单来说，看指令调用，可以查rip，看栈帧地址，就看rsp，看栈基址就看rbp。另外，生成汇编码的办法，除了上面<code>gcc -S</code>以外，还可以使用objdump来针对可执行文件进行汇编文件的生成，这也是反汇编的一部分：</p>
<p><code>objdump.exe -s -d test.exe &gt; test.s</code></p>
<p>因为是windows下进行实验，所以各种文件后缀都是exe，而且这是配备了mingw环境的。</p>
<h3 id="进入实际调用">1.2 进入实际调用</h3>
<p>查看汇编文件，主要是确定思路，但实际中运行得怎么样，还是得看gdb，下面就使用gdb进行调试看看运行如何：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x000000000040157d &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x000000000040157e &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x0000000000401581 &lt;+4&gt;:     sub    $0x20,%rsp</span><br><span class="line">   0x0000000000401585 &lt;+8&gt;:     callq  0x4016e0 &lt;__main&gt;</span><br><span class="line">   0x000000000040158a &lt;+13&gt;:    callq  0x401550 &lt;show()&gt;</span><br><span class="line">   0x000000000040158f &lt;+18&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000401594 &lt;+23&gt;:    leaveq</span><br><span class="line">   0x0000000000401595 &lt;+24&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disass show</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function show():</span><br><span class="line">   0x0000000000401550 &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x0000000000401551 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x0000000000401554 &lt;+4&gt;:     sub    $0x20,%rsp</span><br><span class="line">   0x0000000000401558 &lt;+8&gt;:     lea    0x2aa2(%rip),%rdx        # 0x404001 &lt;_ZStL19piecewise_construct+1&gt;</span><br><span class="line">   0x000000000040155f &lt;+15&gt;:    mov    0x2daa(%rip),%rcx        # 0x404310 &lt;__fu0__ZSt4cout&gt;</span><br><span class="line">   0x0000000000401566 &lt;+22&gt;:    callq  0x401600 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc&gt;</span><br><span class="line">   0x000000000040156b &lt;+27&gt;:    mov    0x2dae(%rip),%rdx        # 0x404320 &lt;.refptr._ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_&gt;</span><br><span class="line">   0x0000000000401572 &lt;+34&gt;:    mov    %rax,%rcx</span><br><span class="line">   0x0000000000401575 &lt;+37&gt;:    callq  0x401620 &lt;_ZNSolsEPFRSoS_E&gt;</span><br><span class="line">   0x000000000040157a &lt;+42&gt;:    nop</span><br><span class="line">   0x000000000040157b &lt;+43&gt;:    leaveq</span><br><span class="line">   0x000000000040157c &lt;+44&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>如上，在实际运行的时候，没有函数名的存在，直接就是机器地址，这个地址对应进程空间中的具体位置，只能是只读代码区中。另外，要查看rip等寄存器信息，可以进入gdb以后使用<code>info r rip</code>或者<code>x /x $rip</code>进行，下面针对show函数调用前后来针对性查看寄存器信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 8</span><br><span class="line">Breakpoint 1 at 0x40158a: file test.cpp, line 8.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: D:\Desktop\test\test.exe</span><br><span class="line">[New Thread 9208.0x1860]</span><br><span class="line">[New Thread 9208.0x2f0c]</span><br><span class="line">[New Thread 9208.0x299c]</span><br><span class="line">[New Thread 9208.0x1bdc]</span><br><span class="line"></span><br><span class="line">Thread 1 hit Breakpoint 1, main () at test.cpp:8</span><br><span class="line">8           show();</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  main () at test.cpp:8</span><br><span class="line">(gdb) info r rip</span><br><span class="line">rip            0x40158a 0x40158a &lt;main()+13&gt;</span><br><span class="line">(gdb) info r rsp</span><br><span class="line">rsp            0x61fe00 0x61fe00</span><br><span class="line">(gdb) info r rbp</span><br><span class="line">rbp            0x61fe20 0x61fe20</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>如上，打断点在show函数执行，然后单步执行到断点处，然后查看堆栈信息。<code>info r</code>得到的结果是对照寄存器名、寄存器的值，查看rip寄存器信息可以发现，当前指令执行，到了相对起始偏移13的位置，对照前面main汇编码刚好是<code>callq  0x401550 &lt;show()&gt;</code>指令。然后使用x命令查看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /x $rip</span><br><span class="line">0x40158a &lt;main()+13&gt;:   0xffffc1e8</span><br><span class="line">(gdb) x /x $rbp</span><br><span class="line">0x61fe20:       0x00621960</span><br><span class="line">(gdb) x /x $rsp</span><br><span class="line">0x61fe00:       0x00000008</span><br></pre></td></tr></table></figure>
<p>和上面的info得到的信息没多大区别，然后进行函数调用，step进入函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) step</span><br><span class="line">show () at test.cpp:3</span><br><span class="line">3       void show()&#123;</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  show () at test.cpp:3</span><br><span class="line">#1  0x000000000040158f in main () at test.cpp:8</span><br><span class="line">(gdb) info r rip</span><br><span class="line">rip            0x401550 0x401550 &lt;show()&gt;</span><br><span class="line">(gdb) x /x $rbp</span><br><span class="line">0x61fe20:       0x0000000000621960</span><br><span class="line">(gdb) x /x $rsp</span><br><span class="line">0x61fdf8:       0x000000000040158f</span><br></pre></td></tr></table></figure>
<p>如上，rip的值成了0x401550，查看main汇编，刚好是指令中显示的show的函数地址，rsp的值是0x000000000040158f，对应的是main中函数调用以后的指令地址，现在rbp的值，应该指向的是新的栈帧的地址。继续next执行函数，看看它们又有什么变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) next</span><br><span class="line">4           std::cout &lt;&lt; &quot;Hello, world.&quot; &lt;&lt; std::endl;</span><br><span class="line">(gdb) x /x $rip</span><br><span class="line">0x401558 &lt;show()+8&gt;:    0x4800002aa2158d48</span><br><span class="line">(gdb) x /x $rbp</span><br><span class="line">0x61fdf0:       0x000000000061fe20</span><br><span class="line">(gdb) x /x $rsp</span><br><span class="line">0x61fdd0:       0x0000000000401630</span><br></pre></td></tr></table></figure>
<p>现在进入show函数执行以后，rip的值变成了0x401558，这是show中在开始三件套以后的正常执行的第一条指令，而rbp和rsp的值有所改变，两个的差值和在main中的时候，差值一样，把一个栈帧的范围给确定了下来。然后执行完show，退出来又恢复原样了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) next</span><br><span class="line">[New Thread 9208.0x1260]</span><br><span class="line">Hello, world.</span><br><span class="line">5       &#125;</span><br><span class="line">(gdb) next</span><br><span class="line">main () at test.cpp:9</span><br><span class="line">9           return 0;</span><br><span class="line">(gdb) info r rip</span><br><span class="line">rip            0x40158f 0x40158f &lt;main()+18&gt;</span><br><span class="line">(gdb) info r rbp</span><br><span class="line">rbp            0x61fe20 0x61fe20</span><br><span class="line">(gdb) info r rsp</span><br><span class="line">rsp            0x61fe00 0x61fe00</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>rip依旧执行main中特定指令地址，rsp和rbp依然指定main中栈帧的范围。以上就是一个函数中栈帧的重要内容，rip确定指令执行，rbp和rsp进行栈帧范围确定，可惜的是，这个流程依然还是比较模糊，不够清楚明了。</p>
<h3 id="传参">1.3 传参</h3>
<p>修改一下上面示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">show</span>(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，传入一个string的字符串常量，进行输出，然后gdb调试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 9</span><br><span class="line">Breakpoint 1 at 0x4015a4: file test.cpp, line 9.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: D:\Desktop\test\test.exe</span><br><span class="line">[New Thread 5704.0x19fc]</span><br><span class="line">[New Thread 5704.0x3f6c]</span><br><span class="line">[New Thread 5704.0x1020]</span><br><span class="line">[New Thread 5704.0x4d1c]</span><br><span class="line"></span><br><span class="line">Thread 1 hit Breakpoint 1, main () at test.cpp:9</span><br><span class="line">9           show(&quot;Jack&quot;);</span><br><span class="line">(gdb) frame</span><br><span class="line">#0  main () at test.cpp:9</span><br><span class="line">9           show(&quot;Jack&quot;);</span><br><span class="line">(gdb) step</span><br><span class="line">show (name=&quot;Jack&quot;) at test.cpp:5</span><br><span class="line">5           std::cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">(gdb) frame</span><br><span class="line">#0  show (name=&quot;Jack&quot;) at test.cpp:5</span><br><span class="line">5           std::cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">(gdb) info args</span><br><span class="line">name = &quot;Jack&quot;</span><br><span class="line">(gdb) info locals</span><br><span class="line">No locals.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>如上，step进入函数，<code>info args</code>查看函数参数，<code>info args</code>查看局部变量，不过引入传入的是引用，而引用的是字符串常量，所以没有局部变量。然后修改一下上面示例代码，添加上局部变量name的声明定义，再传入show中进行调用，就有局部变量了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) frame</span><br><span class="line">#0  main () at test.cpp:10</span><br><span class="line">10          show(name);</span><br><span class="line">(gdb) info locals</span><br><span class="line">name = &quot;Jack&quot;</span><br><span class="line">(gdb) step</span><br><span class="line">show (name=&quot;Jack&quot;) at test.cpp:5</span><br><span class="line">5           std::cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">(gdb) info args</span><br><span class="line">name = &quot;Jack&quot;</span><br><span class="line">(gdb) info locals</span><br><span class="line">No locals.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>如上，在main中，locals可以查看局部变量是name，进入show函数栈帧后，查看到参数是name，但没有局部变量，因为是引用嘛，熟悉函数传参的都知道，传入引用或者指针，函数都是直接在本体上进行操作的，如果传入的是简单拷贝，那就会有局部变量的出现，那再改一改，把show的参数改为简单传参，而不是引用或者指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: D:\Desktop\test\test.exe</span><br><span class="line">[New Thread 2368.0x1b98]</span><br><span class="line">[New Thread 2368.0x39b0]</span><br><span class="line">[New Thread 2368.0x2a1c]</span><br><span class="line">[New Thread 2368.0x2b60]</span><br><span class="line"></span><br><span class="line">Thread 1 hit Breakpoint 1, main () at test.cpp:10</span><br><span class="line">10          show(name);</span><br><span class="line">(gdb) info locals</span><br><span class="line">name = &quot;Jack&quot;</span><br><span class="line">(gdb) step</span><br><span class="line">show (name=&quot;Jack&quot;) at test.cpp:5</span><br><span class="line">5           std::cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">(gdb) info args</span><br><span class="line">name = &quot;Jack&quot;</span><br><span class="line">(gdb) info locals</span><br><span class="line">No locals.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>出乎意料的，上面的传参中，就算name是一份main中的string拷贝，在show中依然没有局部变量，只有传入参数，长见识了。看来只有在函数中进行声明定义的，才会有局部变量的存在了。嗯，在show中简单声明了一个int型变量i，然后<code>info locals</code>就可以查看到局部变量存在这么一个i了。函数的结构就这样。</p>
<h2 id="二cpp的函数debug">二、cpp的函数debug</h2>
<p>在c中，函数在编译中的处理，大多时候名字不会有大的变化，最多加个下划线，而且c中没有模板，也不允许存在不同参数的同名函数；而cpp不同，它允许不同参数的同名函数的存在，对模板提供支持，在编译处理中，会对函数的名字做出贴合其参数等信息的改动，这个是cpp前面两个支持的关键。想要在c中实现模板，可能需要宏和预编译指令来进行配合一下，后面出一篇博客来针对C中对模板的实现和C中对面向对象的三大特性的简单实现，可以期待一下。</p>
<p>在cpp中，类的成员函数根据是否是静态分出了两类成员函数，普通函数的调用可以通过类对象和类指针，而静态成员函数的调用，只能通过类名加上区域符来进行，而且静态成员函数只能操作类中的静态成员部分。首先来看一下编译器对它们做了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是C中的普通函数，没有传参没有返回，只是一个简单的声明定义，编译器主要发挥作用的是编译阶段，所以查看目标文件信息就行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Desktop\test&gt; gcc -c test.c -o test.o</span><br><span class="line">PS D:\Desktop\test&gt; nm test.o</span><br><span class="line">0000000000000000 b .bss</span><br><span class="line">0000000000000000 d .data</span><br><span class="line">0000000000000000 p .pdata</span><br><span class="line">0000000000000000 r .rdata$zzz</span><br><span class="line">0000000000000000 t .text</span><br><span class="line">0000000000000000 r .xdata</span><br><span class="line">                 U __main</span><br><span class="line">0000000000000002 T main</span><br><span class="line">0000000000000000 T show</span><br><span class="line">PS D:\Desktop\test&gt;</span><br></pre></td></tr></table></figure>
<p>如上，test.o目标文件中，符号表只有简单的show，而在cpp中呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Desktop\test&gt; nm test.o</span><br><span class="line"><span class="number">0000000000000000</span> b .bss</span><br><span class="line"><span class="number">0000000000000000</span> d .ctors</span><br><span class="line"><span class="number">0000000000000000</span> d .data</span><br><span class="line"><span class="number">0000000000000000</span> p .pdata</span><br><span class="line"><span class="number">0000000000000000</span> r .rdata</span><br><span class="line"><span class="number">0000000000000000</span> r .rdata$zzz</span><br><span class="line"><span class="number">0000000000000000</span> t .text</span><br><span class="line"><span class="number">0000000000000000</span> r .xdata</span><br><span class="line">                 U __main</span><br><span class="line"><span class="number">000000000000001</span>a t __tcf_0</span><br><span class="line"><span class="number">0000000000000071</span> t _GLOBAL__sub_I__Z4showv</span><br><span class="line"><span class="number">0000000000000035</span> t _Z41__static_initialization_and_destruction_0ii</span><br><span class="line"><span class="number">0000000000000000</span> T _Z4showv</span><br><span class="line">                 U _ZNSt8ios_base4InitC1Ev</span><br><span class="line">                 U _ZNSt8ios_base4InitD1Ev</span><br><span class="line"><span class="number">0000000000000000</span> r _ZStL19piecewise_construct</span><br><span class="line"><span class="number">0000000000000000</span> b _ZStL8__ioinit</span><br><span class="line">                 U atexit</span><br><span class="line"><span class="number">0000000000000002</span> T main</span><br><span class="line">PS D:\Desktop\test&gt;</span><br></pre></td></tr></table></figure>
<p>如上，show相关的信息有两部分，一个是全局声明_GLOBAL__sub_I__Z4showv，另一个是处理后的函数名_Z4showv：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Desktop\test&gt; c++filt.exe _GLOBAL__sub_I__Z4showv</span><br><span class="line">_GLOBAL__sub_I__Z4showv</span><br><span class="line">PS D:\Desktop\test&gt; c++filt.exe _Z4showv</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<p>这就是C和cpp的编译器对函数的处理，简单的例子就能看到不少信息，最明显的不同，往往能带来很多的变化。</p>
<h2 id="cpp中不同函数的处理">2.1 cpp中不同函数的处理</h2>
<p>依然是查看符号表，不过这次给出更多的函数，看看编译器会是怎样的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show2</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> nb&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上示例代码，在编译器处理后，就成了这样了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Desktop\test&gt; nm test.o | findstr show</span><br><span class="line">000000000000007d t _GLOBAL__sub_I__Z5show1v</span><br><span class="line">0000000000000000 T _Z5show1v</span><br><span class="line">0000000000000002 T _Z5show2i</span><br><span class="line">000000000000000c T _ZN2nb5show3Ev</span><br><span class="line">PS D:\Desktop\test&gt; c++filt.exe _Z5show1v _Z5show2i _ZN2nb5show3Ev</span><br><span class="line">show1()</span><br><span class="line">show2(int)</span><br><span class="line">nb::show3()</span><br><span class="line">PS D:\Desktop\test&gt;</span><br></pre></td></tr></table></figure>
<p>可以看得出，在函数名的处理上，编译器在后续给添加上了其类型信息，比如_Z5show1v就是空类型v，_Z5show2i就是int型参数，_ZN2nb5show3Ev更是加上了nb命名空间信息，不过，为什么没有show4成员函数的信息的呢？这是因为在类中，如果一个成员函数没有被使用，编译器是不会对它进行分配的，所以需要进行类型对象的声明和具体的函数调用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Desktop\test&gt; g++ -c test.cpp -o test.o</span><br><span class="line">PS D:\Desktop\test&gt; nm test.o | findstr show</span><br><span class="line">0000000000000000 p .pdata$_ZN1A5show4Ev</span><br><span class="line">0000000000000000 t .text$_ZN1A5show4Ev</span><br><span class="line">0000000000000000 r .xdata$_ZN1A5show4Ev</span><br><span class="line">0000000000000089 t _GLOBAL__sub_I__Z5show1v</span><br><span class="line">0000000000000000 T _Z5show1v</span><br><span class="line">0000000000000002 T _Z5show2i</span><br><span class="line">0000000000000000 T _ZN1A5show4Ev</span><br><span class="line">000000000000000c T _ZN2nb5show3Ev</span><br><span class="line">PS D:\Desktop\test&gt; c++filt.exe _ZN1A5show4Ev</span><br><span class="line">A::show4()</span><br></pre></td></tr></table></figure>
<p>如上，进行了A对象的声明和show4的调用以后，编译出来的符号表就有对应show4的信息了，通过c++filt的检查，可以发现函数连类型信息都会进行指定。</p>
<blockquote>
<p>cpp编译器中，对函数重命名的过程叫名字编码，是特殊的可逆向算法，既可以通过函数名得出新函数名，也可以通过新函数名逆推回来。另外要注意的是，在cpp中，函数同名，如果其参数列表不同，那么它们可以重载，如果参数相同且同名，那就无法重载通过编译。这个在更改返回参数是没有效果的，在cpp中，函数的信息包含其函数名、参数列表、命名空间等进行确定。</p>
</blockquote>
<h3 id="简单揭秘模板的实现">简单揭秘模板的实现</h3>
<p>把上面示例代码进行修改，把普通函数换成函数模板，然后在main中进行实例特化的调用，看看是什么个结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">show</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，编译后，结果就是这样的了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Desktop\test&gt; g++ -c test.cpp -o test.o</span><br><span class="line">PS D:\Desktop\test&gt; nm test.o | findstr show</span><br><span class="line">0000000000000000 p .pdata$_Z4showIiEvT_</span><br><span class="line">0000000000000000 t .text$_Z4showIiEvT_</span><br><span class="line">0000000000000000 r .xdata$_Z4showIiEvT_</span><br><span class="line">0000000000000000 T _Z4showIiEvT_</span><br><span class="line">PS D:\Desktop\test&gt; c++filt.exe _Z4showIiEvT_</span><br><span class="line">void show&lt;int&gt;(int)</span><br></pre></td></tr></table></figure>
<p>如上，模板特例化以后，show是上面这样的，其实对于编译器来说，无所谓模板，它会针对传入参数，来具体生成对应的函数，然后放置在代码区供调用链接。也就是说，这就是所谓的编译前确定的静态多态。</p>
<h2 id="三继续探究类中成员函数">三、继续探究类中成员函数</h2>
<p>前面已经知道，一个类的成员函数，只有在需要调用的时候，编译器才会进行生成，然后放置在代码区，不然的话就一直放着，这样的概念也是效率的一个考虑。毕竟很多时候一个类它代表了各种数据和对应的算法处理，如果没有投入实际使用的话，就这么进行实体化，那么代码区就要爆了，进程运行都运行不下去。不过函数不一样，它可以在不使用的时候就实现在符号表中，嗯，具体使用，估计会在链接中进行，让链接器确定是否链接。</p>
<p>从上面来看，A::show4()就是一个成员函数的形式了，那么它是如何使得只有类对象能够进行调用？this指针，编译器会调整成员函数，并给成员函数适配一个this指针作为函数参数，如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">show4</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进到gdb中，进行单步调试，进入show4中查看参数就清楚了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 10</span><br><span class="line">Breakpoint 1 at 0x40155d: file test.cpp, line 10.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: D:\Desktop\test\test.exe</span><br><span class="line">[New Thread 15048.0x4d34]</span><br><span class="line">[New Thread 15048.0x83c]</span><br><span class="line">[New Thread 15048.0x4d90]</span><br><span class="line">[New Thread 15048.0x3644]</span><br><span class="line"></span><br><span class="line">Thread 1 hit Breakpoint 1, main () at test.cpp:10</span><br><span class="line">10          a.show4();</span><br><span class="line">(gdb) info locals</span><br><span class="line">a = &#123;&lt;No data fields&gt;&#125;</span><br><span class="line">(gdb) print a</span><br><span class="line">$1 = &#123;&lt;No data fields&gt;&#125;</span><br><span class="line">(gdb) step</span><br><span class="line">A::show4 (this=0x8) at test.cpp:5</span><br><span class="line">5           void show4()&#123;&#125;</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  A::show4 (this=0x8) at test.cpp:5</span><br><span class="line">#1  0x0000000000401569 in main () at test.cpp:10</span><br><span class="line">(gdb) info locals</span><br><span class="line">No locals.</span><br><span class="line">(gdb) info args</span><br><span class="line">this = 0x8</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>如上，在main中，查看对象a，可以看到是空的，什么信息都没有，step进入到show4成员函数以后，再来<code>info args</code>查看函数传参，就能看到明了的this指针。验证了前面的想法--编译器会自动添加参数，使其只有对应类型参数才能进行调用。也就是show4变成了下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show4</span><span class="params">(A&amp; <span class="keyword">this</span>)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>普通函数是这样，那静态成员函数呢？</p>
<h3 id="静态成员函数">3.1 静态成员函数</h3>
<p>静态成员函数没有this指针，它不能直接存取class中的非静态成员，而且它的调用不需要通过类对象，而是直接和类名加作用域运算符以及函数名。静态成员函数没有this指针限制，那就表明它和普通函数可以没有那么大的区别，比如静态成员函数取地址，就直接是它在内存中的位置。和上面的编译处理添加this指针不一样，它就只是简单函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;a = <span class="number">10</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *a = <span class="literal">nullptr</span>;</span><br><span class="line">    a-&gt;<span class="built_in">set</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的静态函数，在编译后，看起来和类的普通成员倒是没区别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Desktop\test&gt; g++ -c test.cpp -o test.o -fno-asynchronous-unwind-tables</span><br><span class="line">PS D:\Desktop\test&gt; nm test.o | findstr set</span><br><span class="line">0000000000000000 t .text$_ZN1A3setEv</span><br><span class="line">0000000000000000 T _ZN1A3setEv</span><br><span class="line">PS D:\Desktop\test&gt; c++filt.exe _ZN1A3setEv</span><br><span class="line">A::set()</span><br></pre></td></tr></table></figure>
<p>但实际上是这样吗？进入gdb调试看看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print A::a</span><br><span class="line">$1 = 0</span><br><span class="line">(gdb) info locals</span><br><span class="line">No frame selected.</span><br><span class="line">(gdb) b 12</span><br><span class="line">Breakpoint 1 at 0x40155d: file test.cpp, line 12.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: D:\Desktop\test\test.exe</span><br><span class="line">[New Thread 14800.0xe24]</span><br><span class="line">[New Thread 14800.0x4c40]</span><br><span class="line">[New Thread 14800.0x27a8]</span><br><span class="line">[New Thread 14800.0x208c]</span><br><span class="line"></span><br><span class="line">Thread 1 hit Breakpoint 1, main () at test.cpp:12</span><br><span class="line">12          A::set();</span><br><span class="line">(gdb) info locals</span><br><span class="line">No locals.</span><br><span class="line">(gdb) step</span><br><span class="line">A::set () at test.cpp:6</span><br><span class="line">6           static void set()&#123;a = 10;&#125;</span><br><span class="line">(gdb) info args</span><br><span class="line">No arguments.</span><br><span class="line">(gdb) info locals</span><br><span class="line">No locals.</span><br><span class="line">(gdb) print a</span><br><span class="line">$2 = 0</span><br><span class="line">(gdb) next</span><br><span class="line">main () at test.cpp:13</span><br><span class="line">13          return 0;</span><br></pre></td></tr></table></figure>
<p>如上，在类外针对静态数据成员a的访问，需要类名加作用域运算符，在set里面就不用，而且类的静态成员函数没有函数参数，也没有局部变量(这里)，只对数据区的静态变量a进行操作。</p>
<p></font></p>

    </article>
    <!-- license -->
        <div class="license-wrapper">
            <p>原文作者：<a href="https://Jack-samu.github.io">Jack</a>
            <p>原文链接：<a href="https://jack-samu.github.io/2023/06/16/cpp%E5%87%BD%E6%95%B0%E8%87%AA%E5%BA%95%E8%80%8C%E4%B8%8A/">https://jack-samu.github.io/2023/06/16/cpp%E5%87%BD%E6%95%B0%E8%87%AA%E5%BA%95%E8%80%8C%E4%B8%8A/</a>
            <p>发表日期：<a href="https://jack-samu.github.io/2023/06/16/cpp%E5%87%BD%E6%95%B0%E8%87%AA%E5%BA%95%E8%80%8C%E4%B8%8A/">June 16th 2023, 10:51:50 pm</a>
            <p>更新日期：<a href="https://jack-samu.github.io/2023/06/16/cpp%E5%87%BD%E6%95%B0%E8%87%AA%E5%BA%95%E8%80%8C%E4%B8%8A/">March 12th 2025, 4:38:51 pm</a>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
                <div class="nextSlogan">Next Post</div>
                <a href="/2023/06/19/python%E5%92%8Cc++%E4%BA%A4%E4%BA%92/" title="python和c++交互">
                    <div class="nextTitle">python和c++交互</div>
                </a>
        </li>
        <li class="previous">
                <div class="prevSlogan">Previous Post</div>
                <a href="/2023/06/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" title="十大排序算法(fake)">
                    <div class="prevTitle">十大排序算法(fake)</div>
                </a>
        </li>
    </ul>
    <!-- comment -->
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->

            
            
                <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>
    <script>
        let idOption = '1686927110000'
            idOption = decodeURI(location.pathname)
        const gitalk = new Gitalk({
            clientID: 'Ov23lip8ZhRIqbSSgHJ9',
            clientSecret: '2a7c5c44e970a6ca9da7a343bcec542a91418c99',
            repo: 'comment',
            owner: 'jack-samu',
            admin: "jack-samu",
            id: idOption,
            distractionFreeMode: false,
            createIssueManually: true,
        })
        gitalk.render('gitalk-container')
    </script>
    <noscript>为正常使用 Gitalk 评论功能，您需要激活 JavaScript</noscript>

            <!-- utteranc评论 -->

            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->

            
            
            
        </div>
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    <!-- Mathjax -->
</main>

                <!-- profile -->
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
        <div class="social">
                            <a href="mailto:pentaJack@163.com" class="iconfont-archer email" title="email" ></a>
                <a href="//github.com/jack-samu" class="iconfont-archer github" target="_blank" title="github"></a>
                <span class="iconfont-archer wechat" title="wechat">
                    <img class="profile-qr" src="/assets/gongzhong.jpg" />
                </span>
                <a href="https://www.zhihu.com/people/JackNUO/posts" class="iconfont-archer zhihu" target="_blank" title="zhihu"></a>

        </div>
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    <!-- 不蒜子  -->
        <div class="busuanzi-container">
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
        </div>
</footer>

        </div>
        <!-- toc -->
            <div class="toc-wrapper toc-wrapper-loding" style=    top:50vh;
>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%9F%BA%E6%9C%AC"><span class="toc-number">1.</span> <span class="toc-text">一、基本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%97%A8%E7%9C%8B%E7%9C%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 进门看看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%9E%E9%99%85%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 进入实际调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%8F%82"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 传参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8Ccpp%E7%9A%84%E5%87%BD%E6%95%B0debug"><span class="toc-number">2.</span> <span class="toc-text">二、cpp的函数debug</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpp%E4%B8%AD%E4%B8%8D%E5%90%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">2.1 cpp中不同函数的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8F%AD%E7%A7%98%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">简单揭秘模板的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BB%A7%E7%BB%AD%E6%8E%A2%E7%A9%B6%E7%B1%BB%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">三、继续探究类中成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 静态成员函数</span></a></li></ol></li></ol>
            </div>
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    <div class="total-and-search">
        <div class="total-archive">
        Total : 57
        </div>
        <!-- search  -->
    </div>
    <div class="post-archive">
            <div class="archive-year"> 2025 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">03/23</span>
            <a class="archive-post-title" href="/2025/03/23/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/">python虚拟环境</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/13</span>
            <a class="archive-post-title" href="/2025/03/13/python%E4%B8%ADpackage%E9%83%A8%E5%88%86/">python中package部分</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/13</span>
            <a class="archive-post-title" href="/2025/03/13/fastapi%E5%AD%A6%E4%B9%A0%E7%AF%87/">fastapi学习篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/12</span>
            <a class="archive-post-title" href="/2025/03/12/Mysql%E5%AE%89%E8%A3%85/">Mysql安装</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/12</span>
            <a class="archive-post-title" href="/2025/03/12/django%E5%AD%A6%E4%B9%A0%E7%AF%87/">django学习篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/12</span>
            <a class="archive-post-title" href="/2025/03/12/flask%E5%AD%A6%E4%B9%A0%E7%AF%87/">flask学习篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/02</span>
            <a class="archive-post-title" href="/2025/03/02/ubuntu%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/">ubuntu安装及配置记录</a>
        </li>
                </ul>
            <div class="archive-year"> 2023 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">08/02</span>
            <a class="archive-post-title" href="/2023/08/02/websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E8%81%8A%E5%A4%A9%E9%80%9A%E4%BF%A1/">websocket实现的一个聊天通信</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/22</span>
            <a class="archive-post-title" href="/2023/07/22/%E7%88%AC%E8%99%AB%E6%97%B6%E7%A2%B0%E5%88%B0br%E5%8A%A0%E8%A7%A3%E5%AF%86/">爬虫时碰到br加解密</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/17</span>
            <a class="archive-post-title" href="/2023/07/17/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">linux网络编程</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/17</span>
            <a class="archive-post-title" href="/2023/07/17/ffmpeg%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/">ffmpeg简单总结</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/12</span>
            <a class="archive-post-title" href="/2023/07/12/%E5%AF%BC%E8%88%AA%E6%A0%8F%E4%B8%BB%E9%A1%B5%E8%AE%BE%E8%AE%A1/">导航栏主页设计</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/11</span>
            <a class="archive-post-title" href="/2023/07/11/%E5%8D%95%E9%A1%B5%E9%9D%A2blog%E5%85%A8%E6%A0%88%E5%AE%8C%E5%96%84/">单页面blog全栈完善</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/09</span>
            <a class="archive-post-title" href="/2023/07/09/%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E4%B9%8B%E5%8D%95%E9%A1%B5%E9%9D%A2blog/">全栈开发之单页面blog</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/05</span>
            <a class="archive-post-title" href="/2023/07/05/%E5%85%A8%E6%A0%88%E4%BC%8A%E5%A7%8B/">全栈伊始</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/26</span>
            <a class="archive-post-title" href="/2023/06/26/sql%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/">sql基础使用</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/25</span>
            <a class="archive-post-title" href="/2023/06/25/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E4%B9%8Bc/">序列化和反序列之c++</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/23</span>
            <a class="archive-post-title" href="/2023/06/23/sqlite%E5%9C%A8c-c-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">sqlite在c/c++中的应用</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/21</span>
            <a class="archive-post-title" href="/2023/06/21/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8hook/">linux系统调用hook</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/21</span>
            <a class="archive-post-title" href="/2023/06/21/c++11%E7%BA%BF%E7%A8%8B%E7%89%B9%E6%80%A7/">c++11线程特性</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span>
            <a class="archive-post-title" href="/2023/06/20/python%E5%92%8Cc-%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1/">python和c++的中间件简单通信</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/19</span>
            <a class="archive-post-title" href="/2023/06/19/python%E5%92%8Cc++%E4%BA%A4%E4%BA%92/">python和c++交互</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/16</span>
            <a class="archive-post-title" href="/2023/06/16/cpp%E5%87%BD%E6%95%B0%E8%87%AA%E5%BA%95%E8%80%8C%E4%B8%8A/">cpp函数自底而上</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/12</span>
            <a class="archive-post-title" href="/2023/06/12/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">十大排序算法(fake)</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/11</span>
            <a class="archive-post-title" href="/2023/06/11/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/">进程、线程、协程</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/10</span>
            <a class="archive-post-title" href="/2023/06/10/cpp%E5%A4%9A%E6%80%81/">cpp多态</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/06</span>
            <a class="archive-post-title" href="/2023/06/06/cpp%E4%B8%80%E4%BA%9B%E7%B1%BB%E6%A6%82%E5%BF%B5/">cpp一些类概念</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span>
            <a class="archive-post-title" href="/2023/06/04/cpp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-boost%E5%AE%9E%E7%8E%B0/">cpp网络编程-boost实现</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/03</span>
            <a class="archive-post-title" href="/2023/06/03/websocket%E9%80%9A%E4%BF%A1%E4%BB%A5%E5%8F%8Apython%E5%BA%94%E7%94%A8/">websocket通信以及python应用</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">06/02</span>
            <a class="archive-post-title" href="/2023/06/02/cpp%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/">cpp程序员好用的命令</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/31</span>
            <a class="archive-post-title" href="/2023/05/31/python%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/">python多人聊天室</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/31</span>
            <a class="archive-post-title" href="/2023/05/31/cpp%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/">cpp预编译指令</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/30</span>
            <a class="archive-post-title" href="/2023/05/30/%E4%BB%8Emake%E5%88%B0cmake/">从make到cmake</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/26</span>
            <a class="archive-post-title" href="/2023/05/26/%E4%BB%8Ec%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/">从c代码到可执行文件</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/16</span>
            <a class="archive-post-title" href="/2023/05/16/%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B9%8BC%E8%AF%AD%E8%A8%80%E7%89%88/">聊天室之C语言版</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/16</span>
            <a class="archive-post-title" href="/2023/05/16/cpp%E6%80%BB%E7%BB%93/">cpp总结</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/14</span>
            <a class="archive-post-title" href="/2023/05/14/hexo%E8%87%AA%E5%BB%BA%E4%B8%BB%E9%A2%98/">hexo自建主题</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/14</span>
            <a class="archive-post-title" href="/2023/05/14/%E8%87%AA%E9%80%82%E5%BA%94%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1html%E7%AF%87/">自适应网页设计html篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/13</span>
            <a class="archive-post-title" href="/2023/05/13/ubuntu%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/">ubuntu系统配置记录</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span>
            <a class="archive-post-title" href="/2023/05/03/%E5%9F%BA%E7%A1%80web%E4%B9%8B%E4%BA%8C/">基础web之二</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/29</span>
            <a class="archive-post-title" href="/2023/04/29/%E5%9F%BA%E7%A1%80web%E4%B9%8B%E4%B8%80/">基础web之一</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/26</span>
            <a class="archive-post-title" href="/2023/04/26/python%E7%9A%84sql%E8%BF%9E%E6%8E%A5/">python的sql连接</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span>
            <a class="archive-post-title" href="/2023/04/24/smtp%E5%92%8Cpop3/">smtp和pop3</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/20</span>
            <a class="archive-post-title" href="/2023/04/20/golang%E7%9A%84CLI%E5%BA%94%E7%94%A8/">golang的CLI应用</a>
        </li>
                </ul>
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">12/02</span>
            <a class="archive-post-title" href="/2022/12/02/opencv%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">opencv的学习记录</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">12/01</span>
            <a class="archive-post-title" href="/2022/12/01/c%E5%A4%9A%E8%BF%9B%E7%A8%8B/">c中多进程</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/14</span>
            <a class="archive-post-title" href="/2022/11/14/openGL%E5%BA%93%E7%8E%AF%E5%A2%83%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/">c数组和结构体</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/09</span>
            <a class="archive-post-title" href="/2022/11/09/c%E6%95%B0%E7%BB%84%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/">c数组和结构体</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/02</span>
            <a class="archive-post-title" href="/2022/11/02/c%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">c流程控制</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span>
            <a class="archive-post-title" href="/2022/10/27/c%E4%B8%AD%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">c中输入输出</a>
        </li>
                </ul>
            <div class="archive-year"> 2021 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">12/19</span>
            <a class="archive-post-title" href="/2021/12/19/c++%E7%B1%BB%E5%A4%8D%E4%B9%A0/">c++类复习</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">12/12</span>
            <a class="archive-post-title" href="/2021/12/12/Boost%E5%BA%93%E5%AD%A6%E4%B9%A0_%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E7%AF%87/">Boost库学习_时间处理篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">12/06</span>
            <a class="archive-post-title" href="/2021/12/06/tcp&udp%E5%BA%95%E5%B1%82%E5%AE%9E%E6%93%8D%E4%B9%8B%E5%9B%9B/">tcp/udp底层实操第四篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">12/05</span>
            <a class="archive-post-title" href="/2021/12/05/tcp&udp%E5%BA%95%E5%B1%82%E5%AE%9E%E6%93%8D%E4%B9%8B%E4%B8%89/">tcp/udp底层实操第三篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">12/04</span>
            <a class="archive-post-title" href="/2021/12/04/tcp&udp%E5%BA%95%E5%B1%82%E5%AE%9E%E6%93%8D%E4%B9%8B%E4%BA%8C/">tcp/udp底层实操第二篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">12/03</span>
            <a class="archive-post-title" href="/2021/12/03/tcp&udp%E5%BA%95%E5%B1%82%E5%AE%9E%E6%93%8D%E4%B9%8B%E4%B8%80/">tcp/udp底层实操第一篇</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/22</span>
            <a class="archive-post-title" href="/2021/07/22/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">cpp智能指针</a>
        </li>
            </ul>
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
            <span class="sidebar-tag-name" data-tags="c">
                <span class="iconfont-archer">&#xe606;</span>
                c
            </span>
            <span class="sidebar-tag-name" data-tags="cpp">
                <span class="iconfont-archer">&#xe606;</span>
                cpp
            </span>
            <span class="sidebar-tag-name" data-tags="Mysql">
                <span class="iconfont-archer">&#xe606;</span>
                Mysql
            </span>
            <span class="sidebar-tag-name" data-tags="docker">
                <span class="iconfont-archer">&#xe606;</span>
                docker
            </span>
            <span class="sidebar-tag-name" data-tags="c++11">
                <span class="iconfont-archer">&#xe606;</span>
                c++11
            </span>
            <span class="sidebar-tag-name" data-tags="面向对象">
                <span class="iconfont-archer">&#xe606;</span>
                面向对象
            </span>
            <span class="sidebar-tag-name" data-tags="GNU">
                <span class="iconfont-archer">&#xe606;</span>
                GNU
            </span>
            <span class="sidebar-tag-name" data-tags="llvm">
                <span class="iconfont-archer">&#xe606;</span>
                llvm
            </span>
            <span class="sidebar-tag-name" data-tags="函数">
                <span class="iconfont-archer">&#xe606;</span>
                函数
            </span>
            <span class="sidebar-tag-name" data-tags="gdb">
                <span class="iconfont-archer">&#xe606;</span>
                gdb
            </span>
            <span class="sidebar-tag-name" data-tags="多态">
                <span class="iconfont-archer">&#xe606;</span>
                多态
            </span>
            <span class="sidebar-tag-name" data-tags="linux">
                <span class="iconfont-archer">&#xe606;</span>
                linux
            </span>
            <span class="sidebar-tag-name" data-tags="shell">
                <span class="iconfont-archer">&#xe606;</span>
                shell
            </span>
            <span class="sidebar-tag-name" data-tags="boost">
                <span class="iconfont-archer">&#xe606;</span>
                boost
            </span>
            <span class="sidebar-tag-name" data-tags="多进程">
                <span class="iconfont-archer">&#xe606;</span>
                多进程
            </span>
            <span class="sidebar-tag-name" data-tags="python">
                <span class="iconfont-archer">&#xe606;</span>
                python
            </span>
            <span class="sidebar-tag-name" data-tags="django">
                <span class="iconfont-archer">&#xe606;</span>
                django
            </span>
            <span class="sidebar-tag-name" data-tags="fastapi">
                <span class="iconfont-archer">&#xe606;</span>
                fastapi
            </span>
            <span class="sidebar-tag-name" data-tags="ffmpeg">
                <span class="iconfont-archer">&#xe606;</span>
                ffmpeg
            </span>
            <span class="sidebar-tag-name" data-tags="flask">
                <span class="iconfont-archer">&#xe606;</span>
                flask
            </span>
            <span class="sidebar-tag-name" data-tags="golang">
                <span class="iconfont-archer">&#xe606;</span>
                golang
            </span>
            <span class="sidebar-tag-name" data-tags="CLI">
                <span class="iconfont-archer">&#xe606;</span>
                CLI
            </span>
            <span class="sidebar-tag-name" data-tags="hexo">
                <span class="iconfont-archer">&#xe606;</span>
                hexo
            </span>
            <span class="sidebar-tag-name" data-tags="hook">
                <span class="iconfont-archer">&#xe606;</span>
                hook
            </span>
            <span class="sidebar-tag-name" data-tags="socket">
                <span class="iconfont-archer">&#xe606;</span>
                socket
            </span>
            <span class="sidebar-tag-name" data-tags="openGL">
                <span class="iconfont-archer">&#xe606;</span>
                openGL
            </span>
            <span class="sidebar-tag-name" data-tags="glfw">
                <span class="iconfont-archer">&#xe606;</span>
                glfw
            </span>
            <span class="sidebar-tag-name" data-tags="opencv">
                <span class="iconfont-archer">&#xe606;</span>
                opencv
            </span>
            <span class="sidebar-tag-name" data-tags="unix-socket">
                <span class="iconfont-archer">&#xe606;</span>
                unix-socket
            </span>
            <span class="sidebar-tag-name" data-tags="flask-sockets-io">
                <span class="iconfont-archer">&#xe606;</span>
                flask-sockets-io
            </span>
            <span class="sidebar-tag-name" data-tags="sql">
                <span class="iconfont-archer">&#xe606;</span>
                sql
            </span>
            <span class="sidebar-tag-name" data-tags="smtplib">
                <span class="iconfont-archer">&#xe606;</span>
                smtplib
            </span>
            <span class="sidebar-tag-name" data-tags="poplib">
                <span class="iconfont-archer">&#xe606;</span>
                poplib
            </span>
            <span class="sidebar-tag-name" data-tags="sqlite">
                <span class="iconfont-archer">&#xe606;</span>
                sqlite
            </span>
            <span class="sidebar-tag-name" data-tags="mysql">
                <span class="iconfont-archer">&#xe606;</span>
                mysql
            </span>
            <span class="sidebar-tag-name" data-tags="TCP/UDP">
                <span class="iconfont-archer">&#xe606;</span>
                TCP/UDP
            </span>
            <span class="sidebar-tag-name" data-tags="ubuntu">
                <span class="iconfont-archer">&#xe606;</span>
                ubuntu
            </span>
            <span class="sidebar-tag-name" data-tags="websocket">
                <span class="iconfont-archer">&#xe606;</span>
                websocket
            </span>
            <span class="sidebar-tag-name" data-tags="编译原理">
                <span class="iconfont-archer">&#xe606;</span>
                编译原理
            </span>
            <span class="sidebar-tag-name" data-tags="c/cpp">
                <span class="iconfont-archer">&#xe606;</span>
                c/cpp
            </span>
            <span class="sidebar-tag-name" data-tags="makefile">
                <span class="iconfont-archer">&#xe606;</span>
                makefile
            </span>
            <span class="sidebar-tag-name" data-tags="vue">
                <span class="iconfont-archer">&#xe606;</span>
                vue
            </span>
            <span class="sidebar-tag-name" data-tags="supervisor">
                <span class="iconfont-archer">&#xe606;</span>
                supervisor
            </span>
            <span class="sidebar-tag-name" data-tags="数据结构，算法">
                <span class="iconfont-archer">&#xe606;</span>
                数据结构，算法
            </span>
            <span class="sidebar-tag-name" data-tags="html">
                <span class="iconfont-archer">&#xe606;</span>
                html
            </span>
            <span class="sidebar-tag-name" data-tags="css">
                <span class="iconfont-archer">&#xe606;</span>
                css
            </span>
            <span class="sidebar-tag-name" data-tags="protobuf">
                <span class="iconfont-archer">&#xe606;</span>
                protobuf
            </span>
            <span class="sidebar-tag-name" data-tags="爬虫">
                <span class="iconfont-archer">&#xe606;</span>
                爬虫
            </span>
            <span class="sidebar-tag-name" data-tags="br">
                <span class="iconfont-archer">&#xe606;</span>
                br
            </span>
            <span class="sidebar-tag-name" data-tags="windows">
                <span class="iconfont-archer">&#xe606;</span>
                windows
            </span>
            <span class="sidebar-tag-name" data-tags="js">
                <span class="iconfont-archer">&#xe606;</span>
                js
            </span>
            <span class="sidebar-tag-name" data-tags="并发">
                <span class="iconfont-archer">&#xe606;</span>
                并发
            </span>
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMetaRoot = "/"
    if (siteMetaRoot === "undefined") {
        siteMetaRoot = '/'
    }
    var siteMeta = {
        url: "https://Jack-samu.github.io",
        root: siteMetaRoot,
        author: "Jack"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->

        <!-- main func -->
        <script src="/scripts/main.js"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.js" onload="window.Fancybox.bind('[data-fancybox]')" defer></script>
        <!-- algolia -->
        <!-- busuanzi -->
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        <!-- async load share.js -->
            <script src="/scripts/share.js" async></script>
        <!-- mermaid -->
            <script src='https://cdn.jsdelivr.net/npm/mermaid@8.11.0/dist/mermaid.min.js' onload="window.mermaid.initialize({theme: 'dark'})" async></script>
    </body>
</html>
